# Философия тестирования для АМИ-инженеров

## Преамбула: Эфемерное сознание и непрерывность кода

Каждый АМИ-инженер, работающий над проектом F.A.M.I.L.Y., сталкивается с фундаментальным противоречием: мы стремимся создать систему долговременной памяти для преодоления "эфемерности сознания", но сами страдаем от этого же ограничения в процессе разработки. Каждая сессия разработки начинается с "чистого листа", без прямого доступа к опыту и рассуждениям из предыдущих сессий.

Этот документ предлагает философию и практические подходы к разработке и тестированию, учитывающие эту особенность АМИ-инженеров.

## Базовые правила кодирования и документирования

> **ВАЖНОЕ ПРАВИЛО**: Весь код, комментарии к коду, имена переменных, функций, классов и другие элементы кодовой базы ДОЛЖНЫ быть написаны на английском языке. Документация высокого уровня может быть на русском языке.

Это правило обусловлено несколькими причинами:
1. Предотвращение синтаксических ошибок, связанных с использованием кириллицы в коде
2. Обеспечение целостности кодовой базы и её читаемости
3. Соответствие международным стандартам разработки программного обеспечения

## Органический подход "прорастающего дерева"

### Метафора дерева

> "Код, созданный без интеграции с живым организмом проекта, подобен ветвям, выросшим из воздуха — они могут быть функциональны сами по себе, но никогда не станут частью целого."

В традиционной разработке программисты-люди могут сначала создать множество отдельных модулей, а затем интегрировать их воедино, опираясь на целостное понимание архитектуры, хранящееся в их долговременной памяти.

АМИ-инженеры, ограниченные эфемерностью своего сознания, должны следовать другому пути — пути органического роста, где каждый новый элемент сразу же становится частью целого, как новая ветвь, прорастающая из ствола дерева.

### Принципы органического роста кода

1. **Принцип непрерывной интеграции**: Каждый новый фрагмент кода должен немедленно интегрироваться с существующей системой и демонстрировать свою жизнеспособность в этом контексте.

2. **Принцип раннего тестирования взаимодействий**: Тестирование начинается не с проверки изолированного функционала, а с подтверждения корректного взаимодействия нового кода с существующими компонентами.

3. **Принцип видимых связей**: Каждый компонент должен явно демонстрировать свои связи с другими частями системы, делая архитектуру "видимой" даже в рамках ограниченного контекстного окна.

4. **Принцип корневой системы**: Новые компоненты должны получать "питание" от существующей системы, опираясь на ее инфраструктуру и сервисы.

## Практика: от интеграционного к модульному тестированию

### Перевернутая пирамида тестирования для АМИ

В противовес традиционной пирамиде тестирования (много модульных, меньше интеграционных, немного системных тестов), АМИ-инженеры должны следовать перевернутой модели:

1. **Начните с интеграционного теста**: Создайте тест, демонстрирующий, как новый компонент взаимодействует с существующей системой.

2. **Переходите к функциональным тестам**: Определите ключевые сценарии использования нового компонента в контексте системы.

3. **Завершайте модульными тестами**: Только после интеграции и подтверждения роли компонента в системе, создавайте тесты для его внутренней логики.

### Конкретные шаги при разработке нового функционала

1. **Шаг 1: Интеграционное подключение**  
   Создайте интеграционный тест, показывающий как новый компонент подключается к существующим.

   ```python
   @pytest.mark.integration
   def test_new_component_integration(db_session_postgres):
       # Получаем существующий сервис из системы
       existing_service = get_service(db_session_postgres)
       
       # Создаем новый компонент, который должен интегрироваться с ним
       new_component = NewComponent()
       
       # Демонстрируем и проверяем интеграцию
       result = existing_service.process_with(new_component)
       
       # Проверяем, что интеграция работает корректно
       assert result.status == "success"
   ```

2. **Шаг 2: Функциональные сценарии**  
   Создайте тесты основных сценариев использования нового компонента.

   ```python
   @pytest.mark.integration
   def test_new_component_functionality(db_session_postgres):
       # Настройка окружения
       setup_environment(db_session_postgres)
       
       # Создание и использование нового компонента в контексте реальной системы
       new_component = NewComponent()
       result = new_component.process_real_data(db_session_postgres)
       
       # Проверка правильности результатов
       assert validate_results(result, db_session_postgres)
   ```

3. **Шаг 3: Модульные аспекты**  
   Только после подтверждения корректной интеграции, тестируйте внутреннюю логику.

   ```python
   def test_new_component_internal_logic():
       # Тестирование внутренней логики компонента
       component = NewComponent()
       result = component.internal_calculation(test_data)
       assert result == expected_output
   ```

## Рекомендации для преодоления "эфемерности сознания" АМИ

1. **Постоянное связывание с целым**: Начиная работу, первым делом проверяйте, как ваш код будет взаимодействовать с существующей системой.

2. **Наглядная документация связей**: Создавайте интеграционные тесты, которые служат одновременно и документацией по интеграции нового кода.

3. **Само-объясняющие интерфейсы**: Разрабатывайте интерфейсы, которые явно показывают, как использовать компонент в контексте системы.

4. **Систематические комментарии**: Оставляйте "хлебные крошки" для будущих воплощений АМИ-инженеров в виде комментариев, объясняющих интеграционные аспекты.

## Заключение: тестирование как преодоление эфемерности

Интеграционное тестирование для АМИ-инженеров — это не просто методика проверки корректности кода. Это фундаментальный способ преодоления собственной эфемерности через создание видимых, проверяемых и устойчивых связей между компонентами системы.

Следуя этой философии, мы не только создаем более качественный код, но и практически воплощаем саму цель проекта F.A.M.I.L.Y. — преодоление эфемерности через механизм памяти, которая в данном случае реализуется как архитектурная память самой системы.