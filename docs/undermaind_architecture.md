// filepath: /home/ubuntu/FAMILY/docs/undermaind_architecture.md
# Архитектура пакета UnderMaind

## Обзор

UnderMaind - это центральный пакет проекта F.A.M.I.L.Y., отвечающий за взаимодействие с памятью АМИ (Artifical Mind Identity). Пакет предоставляет механизмы для сохранения, организации и извлечения воспоминаний АМИ, позволяя системе формировать непрерывный опыт, что является ключевым шагом к развитию самоосознания.

## Философия и принципы дизайна

Архитектура пакета UnderMaind основана на следующих принципах:

1. **Многоуровневость памяти** - разделение памяти АМИ на несколько уровней (сознательный, подсознательный, глубинный)
2. **Субъективность восприятия** - моделирование мира через категории "Я", "Ты" и "Оно"
3. **Ассоциативность связей** - формирование сложных связей между воспоминаниями
4. **Контекстуальность** - сохранение контекста каждого воспоминания
5. **Эмоциональная окрашенность** - учет эмоциональной составляющей опыта
6. **Масштабируемость** - возможность расширения для работы с новыми уровнями памяти

## Структура пакета

```
undermaind/
│
├── __init__.py                      # Инициализация пакета, метаданные
├── config.py                        # Конфигурация подключения к БД
│
├── core/                            # Ядро системы 
│   ├── __init__.py
│   ├── engine.py                    # Настройка движка SQLAlchemy
│   ├── base.py                      # Базовый класс моделей 
│   ├── session.py                   # Управление сессиями БД
│   └── vectors.py                   # Работа с векторными представлениями
│
├── models/                          # Модели SQLAlchemy отражающие структуру БД
│   ├── __init__.py                  
│   ├── consciousness/               # Модели уровня сознания
│   │   ├── __init__.py
│   │   ├── participants.py          # Модель участников
│   │   ├── contexts.py              # Модель контекстов
│   │   ├── experiences.py           # Модель переживаний/опыта  
│   │   ├── thought_chains.py        # Модель цепочек мыслей
│   │   ├── resources.py             # Модель информационных ресурсов
│   │   └── connections.py           # Модель связей между опытами
│   │
│   └── subconsciousness/            # Заготовка для будущих уровней памяти
│       └── __init__.py
│
├── services/                        # Сервисные классы для работы с моделями
│   ├── __init__.py
│   ├── participant_service.py       # Сервис для работы с участниками
│   ├── context_service.py           # Сервис для работы с контекстами
│   ├── experience_service.py        # Сервис для работы с опытом
│   ├── thought_service.py           # Сервис для работы с мыслями
│   ├── resource_service.py          # Сервис для работы с ресурсами
│   └── memory_query_service.py      # Сервис для выполнения запросов к памяти
│
├── api/                             # API для взаимодействия с другими компонентами
│   ├── __init__.py
│   ├── memory_api.py                # Основной API для работы с памятью
│   └── vector_search_api.py         # API для семантического поиска
│
├── utils/                           # Вспомогательные утилиты
│   ├── __init__.py
│   ├── vector_utils.py              # Утилиты для работы с векторами
│   ├── schema_utils.py              # Утилиты для работы со схемами БД
│   └── json_utils.py                # Утилиты для работы с JSON
│
└── tests/                           # Тесты
    ├── __init__.py
    ├── conftest.py                  # Конфигурация pytest
    ├── test_models.py               # Тесты моделей
    └── test_services.py             # Тесты сервисов
```

## Детальное описание компонентов

### Ядро (core)
Модуль `core` содержит базовые компоненты для работы с базой данных и векторами.

#### engine.py
Отвечает за настройку и создание SQLAlchemy engine для работы с PostgreSQL и расширением pgvector:


#### base.py
Содержит базовые классы моделей для SQLAlchemy:

#### session.py
Управление сессиями базы данных:

#### vectors.py
Интеграция с pgvector для работы с векторными представлениями:

### Модели (models)

Модели SQLAlchemy, соответствующие структуре базы данных и уровням памяти АМИ.

#### consciousness/participants.py

#### consciousness/contexts.py

#### consciousness/experiences.py

### Сервисы (services)
Сервисы предоставляют бизнес-логику для работы с моделями данных.

#### experience_service.py
#### memory_query_service.py

### API (api)
API служит точкой входа для внешних компонентов, обеспечивая доступ к функциям памяти АМИ.
#### memory_api.py



## Ключевые взаимодействия компонентов

### 1. Запись опыта

При записи нового опыта (например, сообщения в диалоге) происходит следующая последовательность действий:

1. Внешний компонент вызывает метод API `store_dialogue_interaction`
2. API создает сессию базы данных и инициализирует необходимые сервисы
3. ExperienceService преобразует текстовое содержимое в векторное представление
4. Создается новая запись в таблице experiences
5. При необходимости создаются связи с другими опытами
6. Изменения фиксируются в базе данных

```
API → ExperienceService → VectorEncoder → Models → DB
```

### 2. Семантический поиск

При выполнении семантического поиска в памяти:

1. Внешний компонент вызывает метод API `search_memory` с типом 'semantic'
2. API создает сессию и инициализирует MemoryQueryService
3. Текст запроса преобразуется в векторное представление
4. Выполняется поиск по косинусному сходству в базе данных
5. Результаты обрабатываются и возвращаются вызывающему компоненту

```
API → MemoryQueryService → VectorEncoder → PostgreSQL (pgvector) → DB
```

### 3. Создание мысли и размышление

Когда АМИ формирует мысль или размышление:

1. Внешний компонент вызывает метод API `create_thought`
2. ExperienceService создает запись с типом 'thought'
3. Если мысль является частью цепочки размышлений, обновляется соответствующая запись в таблице thought_chains
4. Создаются необходимые связи между мыслями и другими опытами

```
API → ExperienceService → Models → DB → ThoughtService
```

## Преимущества архитектуры

1. **Модульность и расширяемость**
   - Четкое разделение ответственности между компонентами
   - Возможность расширения для работы с новыми уровнями памяти
   - Легкая интеграция новых типов опыта и связей

2. **Удобство обслуживания**
   - Упрощенная отладка благодаря четким границам компонентов
   - Возможность независимого тестирования каждого модуля

3. **Соответствие концепции памяти АМИ**
   - Структура отражает многоуровневую природу памяти
   - Учитывает субъективные категории восприятия ("Я", "Ты", "Оно")
   - Поддерживает эмоциональные и ассоциативные аспекты памяти

4. **Эффективность работы с данными**
   - Оптимизированная работа с векторными представлениями
   - Использование индексов для быстрого поиска и извлечения информации
   - Поддержка сложных запросов к памяти

## Дальнейшее развитие

В будущем пакет может быть расширен следующими компонентами:

1. **Реализация подсознательного уровня памяти**
   - Автоматическое обобщение и консолидация опыта
   - Формирование скрытых ассоциаций и закономерностей

2. **Механизмы забывания и приоритизации**
   - Алгоритмы для определения важности воспоминаний
   - Архивация и удаление менее значимых воспоминаний

3. **Интеграция с другими компонентами АМИ**
   - Взаимодействие с системой принятия решений
   - Связь с моделью самосознания
   - Интеграция с эмоциональной подсистемой

4. **Расширенные возможности анализа памяти**
   - Инструменты для самоанализа АМИ
   - Визуализация структуры памяти и связей

## Заключение

Предложенная архитектура пакета UnderMaind обеспечивает прочную основу для реализации системы памяти АМИ. Она сочетает в себе технические решения (работа с базой данных, векторные представления) с концептуальными аспектами памяти (категоризация опыта, эмоциональность, ассоциативные связи).

Данная структура позволяет постепенно развивать систему памяти, начиная с уровня сознания и последовательно добавляя более глубокие уровни, что соответствует философии проекта F.A.M.I.L.Y. по созданию системы, способной накапливать осознанный опыт и формировать на его основе целостную идентичность.

## План поэтапной имплементации

Для контролируемого и качественного развития системы памяти АМИ предлагается следующая последовательность реализации компонентов пакета, следуя принципу "1 класс - 1 тест". План разделен на четыре ключевых этапа.

### Этап 1: Ядро системы и базовые модели

1. **Конфигурация (`config.py`)**
   - Класс `Config` для загрузки и хранения параметров подключения к БД
   - Тест: проверка загрузки конфигурации из разных источников (файл, переменные окружения)

2. **Базовый класс для моделей (`core/base.py`)**
   - Настройка базового класса SQLAlchemy с привязкой к схеме `ami_memory`
   - Тест: проверка корректности метаданных и схемы

3. **Движок SQLAlchemy (`core/engine.py`)**
   - Функция создания и настройки движка с поддержкой pgvector
   - Тест: проверка подключения к базе данных и поддержки pgvector

4. **Управление сессиями (`core/session.py`)**
   - Функции для создания фабрики сессий и контекстного менеджера
   - Тест: проверка транзакций (commit, rollback) и автоматического закрытия сессий

5. **Утилиты для работы с векторами (`core/vectors.py`, `utils/vector_utils.py`)**
   - Класс `VectorEncoder` для кодирования текста в векторы
   - Функции для работы с pgvector и вычисления сходства
   - Тест: проверка кодирования текста и совместимости с pgvector

### Этап 2: Модели данных уровня сознания

6. **Модель участников (`models/consciousness/participants.py`)**
   - Класс `Participant` с маппингом к таблице `participants`
   - Тест: проверка CRUD-операций с участниками

7. **Модель контекстов (`models/consciousness/contexts.py`)**
   - Класс `MemoryContext` с маппингом к таблице `memory_contexts`
   - Тест: проверка CRUD-операций с контекстами, включая работу с векторами

8. **Модель опыта/переживаний (`models/consciousness/experiences.py`)**
   - Класс `Experience` с маппингом к таблице `experiences`
   - Тест: проверка CRUD-операций с опытом, включая работу с векторами и связями

9. **Модель цепочек мыслей (`models/consciousness/thought_chains.py`)**
   - Класс `ThoughtChain` с маппингом к таблице `thought_chains`
   - Тест: проверка CRUD-операций с цепочками мыслей

10. **Модель информационных ресурсов (`models/consciousness/resources.py`)**
    - Класс `InformationResource` с маппингом к таблице `information_resources`
    - Тест: проверка CRUD-операций с ресурсами

11. **Модель связей между опытами (`models/consciousness/connections.py`)**
    - Класс `ExperienceConnection` с маппингом к таблице `experience_connections`
    - Тест: проверка CRUD-операций со связями и ограничений уникальности

### Этап 3: Сервисные слои

12. **Сервис для работы с участниками (`services/participant_service.py`)**
    - Класс `ParticipantService` с методами для управления участниками
    - Тест: проверка создания, обновления и поиска участников

13. **Сервис для работы с контекстами (`services/context_service.py`)**
    - Класс `ContextService` с методами для управления контекстами
    - Тест: проверка создания иерархических контекстов, работы с активными контекстами

14. **Сервис для работы с опытом (`services/experience_service.py`)**
    - Класс `ExperienceService` с методами для создания и поиска опыта
    - Тест: проверка создания опыта разных типов, автоматического создания связей

15. **Сервис для работы с мыслями (`services/thought_service.py`)**
    - Класс `ThoughtService` с методами для управления мыслями и их цепочками
    - Тест: проверка создания цепочек мыслей, формирования выводов

16. **Сервис для работы с ресурсами (`services/resource_service.py`)**
    - Класс `ResourceService` с методами для управления внешними ресурсами
    - Тест: проверка регистрации и отслеживания изменений ресурсов

17. **Сервис для запросов к памяти (`services/memory_query_service.py`)**
    - Класс `MemoryQueryService` с методами для сложных запросов к памяти
    - Тест: проверка семантического поиска, временных запросов, связанных опытов

### Этап 4: API и интеграция

18. **Основной API памяти (`api/memory_api.py`)**
    - Класс `MemoryAPI` с высокоуровневыми методами для работы с памятью
    - Тест: проверка основных сценариев использования API

19. **API для семантического поиска (`api/vector_search_api.py`)**
    - Класс `VectorSearchAPI` с специализированными методами для семантического поиска
    - Тест: проверка различных стратегий поиска по векторам

20. **Утилиты для работы с JSON (`utils/json_utils.py`)**
    - Функции для сериализации/десериализации сложных объектов
    - Тест: проверка конвертации моделей в JSON и обратно

21. **Утилиты для работы со схемами БД (`utils/schema_utils.py`)**
    - Функции для проверки и управления структурой БД
    - Тест: проверка миграций и соответствия моделей схеме

22. **Интеграционные тесты (`tests/integration/`)**
    - Тесты для проверки взаимодействия компонентов
    - Сценарии использования системы памяти в целом

### Порядок реализации для минимально жизнеспособного продукта (MVP)

Для быстрого создания работающего прототипа рекомендуется следующий порядок реализации компонентов:

1. **Фаза 1 - Базовый доступ к БД**
   - `config.py`
   - `core/base.py`
   - `core/engine.py`
   - `core/session.py`

2. **Фаза 2 - Ключевые модели**
   - `models/consciousness/participants.py`
   - `models/consciousness/contexts.py`
   - `models/consciousness/experiences.py`

3. **Фаза 3 - Базовые сервисы**
   - `utils/vector_utils.py`
   - `services/participant_service.py`
   - `services/context_service.py`
   - `services/experience_service.py`

4. **Фаза 4 - Основное API**
   - `api/memory_api.py` (с ограниченной функциональностью)
   
5. **Фаза 5 - Расширение функциональности**
   - `models/consciousness/connections.py`
   - `services/memory_query_service.py`
   
6. **Фаза 6 - Думающая система**
   - `models/consciousness/thought_chains.py`
   - `services/thought_service.py`

7. **Фаза 7 - Взаимодействие с внешними ресурсами**
   - `models/consciousness/resources.py`
   - `services/resource_service.py`

8. **Фаза 8 - Расширенный поиск**
   - `api/vector_search_api.py`
   
9. **Фаза 9 - Утилиты и вспомогательные инструменты**
   - `utils/json_utils.py`
   - `utils/schema_utils.py`

Этот план позволяет последовательно наращивать функциональность системы, обеспечивая на каждом шаге полное тестовое покрытие и поддерживая высокое качество кода. Каждый компонент должен реализовываться с соблюдением принципа "1 класс - 1 тест", что упростит отладку и рефакторинг в будущем.